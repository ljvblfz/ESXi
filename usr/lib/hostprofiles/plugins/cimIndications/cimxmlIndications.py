#!/usr/bin/env python
# Hey Emacs, -*- mode: Python; coding: utf-8 -*-
# **********************************************************
'''
For details on Host Profiles plugins see
https://wiki/VmKag/Projects/MNHostProfiles/Extensibility/PluginHowTo
https://wiki/VmKag/Projects/MNHostProfiles/Extensibility#Examples
'''
__author__ = "VMware, Inc."
__copyright__ = "Copyright 2010-2014 VMware, Inc.  All rights reserved."

import socket

import json
import os
import tempfile
from pluginApi import ParameterMetadata, \
                      CreateLocalizedMessage, \
                      CreateLocalizedException
from pluginApi import log
from pluginApi import CATEGORY_GENERAL_SYSTEM_SETTING, COMPONENT_MANAGED_AGENT_CONFIG
from pluginApi.extensions import SimpleConfigProfile
from pluginApi.extensions import StandardizeIPv6Address, IsIPInaddrAny

from . import cimIndicationsProfile
from pyVmomi.VmomiSupport import ResolveLinks
from vmware import runcommand

try:
   from urllib.parse import urlparse
except ImportError:
   from urlparse import urlparse
#
# Define some constants first
#
INTEROP_NS = 'root/interop'

LISTENER_DESTINATION = 'listenerDestination'
QUERY_LANGUAGE = 'queryLanguage'
QUERY = 'query'
SOURCE_NAMESPACE = 'sourceNamespace'
SOURCE_NAMESPACES = 'sourceNamespaces'

LISTENER_CLASS = 'listenerClass'
LISTENER_NAME = 'listenerName'
LISTENER_SYSTEM_NAME = 'listenerSystemName'
LISTENER_SYSTEM_CCN = 'listenerSystemCreationClassName'

FILTER_CLASS = 'filterClass'
FILTER_NAME = 'filterName'
FILTER_SYSTEM_NAME = 'filterSystemName'
FILTER_SYSTEM_CCN = 'filterSystemCreationClassName'

# The set of keys used to access the JSON config file as generated by indcfg:

JSN_FILTER_PROP = 'filt'
JSN_HANDLER_PROP = 'hdl'
JSN_QUERY_PROP = 'query'
JSN_SOURCE_NAMESPACE_PROP = 'sns'
JSN_DESTINATION_PROP = 'dest'
JSN_SUB_PROP = 'subs'
JSN_F_CLASSNAME_PROP = "fcls"
JSN_F_SYSTEMNAME_PROP = "fsn"
JSN_F_SYSTEMCLASS_PROP = "fsc"
JSN_SOURCE_NAMESPACES_PROP = 'snss'
JSN_QUERY_LANGUAGE_PROP = 'qlang'
JSN_H_CLASSNAME_PROP = "hcls"
JSN_H_SYSTEMNAME_PROP = "hsn"
JSN_H_SYSTEMCLASS_PROP = "hsc"

# touch this file to keep intermediary json file around
DEBUG_FLAG = '/tmp/debug_cim_ind'

#
# Define the localization message catalog keys used by this profile
#
BASE_MSG_KEY = 'com.vmware.profile.Profile.CimXmlIndicationsProfile'
DUPLICATE_FILTER_IDENTIFIERS_MSG_KEY = '%s.DuplicateFilterIds' % BASE_MSG_KEY
DUPLICATE_DEST_IDENTIFIERS_MSG_KEY = '%s.DuplicateDestinationIds' % BASE_MSG_KEY
DUPLICATE_SUBSCRIPTION_MSG_KEY = '%s.DuplicateSubscription' % BASE_MSG_KEY
FILTER_CREATION_EXCEPTION_MSG_KEY = '%s.FilterCreateException' % BASE_MSG_KEY
FILTER_DELETION_EXCEPTION_MSG_KEY = '%s.FilterDeleteException' % BASE_MSG_KEY
DEST_CREATION_EXCEPTION_MSG_KEY = '%s.DestCreateException' % BASE_MSG_KEY
DEST_DELETION_EXCEPTION_MSG_KEY = '%s.DestDeleteException' % BASE_MSG_KEY
SUB_CREATION_EXCEPTION_MSG_KEY = '%s.SubCreateException' % BASE_MSG_KEY
SUB_DELETION_EXCEPTION_MSG_KEY = '%s.SubDeleteException' % BASE_MSG_KEY
EXTRACTION_EXCEPTION_MSG_KEY = '%s.ExtractionException' % BASE_MSG_KEY
UNKNOWN_EXTRACTION_EXCEPTION_MSG_KEY = \
      '%s.UnknownExtractionException' % BASE_MSG_KEY

HOSTNAME_SUBSTITUTION = '<!HOSTNAME>'
IPVX_SUBSTITUTION = '<!IPVX>'

# The path to a temporary file used to store cim indications in json format
TMP_CONFIG_FILE = tempfile.mktemp('.jsn','hp_cim_ind_cfg_','/tmp')

def _CreateExceptionFromObject(catalogKey, obj):
   """A helper function that creates a localized exception object for the given
      catalog key and a caught exception object.
   """
   objList = obj
   if not isinstance(obj, list):
      objList = [ obj ]

   keyValDict = dict()
   argIndex = 0
   for errObj in objList:
      arg = 'ErrArg%s' % str(argIndex)
      argIndex += 1
      keyValDict[arg] = str(errObj)

   return CreateLocalizedException(None, catalogKey, keyValDict)


def get_config(path):
   '''generate a json file with cim indication state'''
   app_args = ['/bin/indcfg', '--read', path]
   log.debug("CIMXML: reading cim configuration and saving it to %s" % path)
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

def load_config():
   ''' run extraction tool, load the json file and return the config'''
   get_config(TMP_CONFIG_FILE)
   cfg_data = None
   with open(TMP_CONFIG_FILE) as cfg:
      cfg_data = json.load(cfg)
   if not os.path.exists(DEBUG_FLAG):
      os.unlink(TMP_CONFIG_FILE)
   return cfg_data

def set_config(path):
   '''install cimxml config from a json file located by path'''
   app_args = ['/bin/indcfg', '--write', path]
   log.debug("CIMXML: writing cim configuration from %s" % path)
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

def clear_config():
   '''clear cimxml config'''
   app_args = ['/bin/indcfg', '--clear']
   log.debug("CIMXML: clearing cim configuration")
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

def is_sfcbrunning():
   '''get sfcbd status'''
   app_args = ['/etc/init.d/sfcbd-watchdog', 'status']
   log.debug("CIMXML: get sfcbd status")
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

def start_sfcb():
   '''start sfcbd'''
   app_args = ['/etc/init.d/sfcbd-watchdog', 'start']
   log.debug("CIMXML: start sfcbd")
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

def stop_sfcb():
   '''start sfcbd'''
   app_args = ['/etc/init.d/sfcbd-watchdog', 'stop']
   log.debug("CIMXML: stop sfcbd")
   status, output = runcommand.runcommand(app_args)
   return (status == 0)

class CimXmlIndicationsProfile(SimpleConfigProfile):
   """A Host Profile that manages CIM-XML Indication Subscriptions on ESX hosts.
   """
   #
   # Define required class attributes
   #
   # TBD: Add validators for queryLanguage and listenerDestination
   parameters = [
      # Parameters for the indication filter
      ParameterMetadata(FILTER_CLASS, 'string', False),
      ParameterMetadata(FILTER_NAME, 'string', False),
      ParameterMetadata(FILTER_SYSTEM_NAME, 'string', False),
      ParameterMetadata(FILTER_SYSTEM_CCN, 'string', False),
      ParameterMetadata(QUERY_LANGUAGE, 'string', False),
      ParameterMetadata(QUERY, 'string', False),
      ParameterMetadata(SOURCE_NAMESPACE, 'string', False),
      ParameterMetadata(SOURCE_NAMESPACES, 'string[]', False),

      ParameterMetadata(LISTENER_CLASS, 'string', False),
      ParameterMetadata(LISTENER_NAME, 'string', False),
      ParameterMetadata(LISTENER_SYSTEM_NAME, 'string', False),
      ParameterMetadata(LISTENER_SYSTEM_CCN, 'string', False),
      ParameterMetadata(LISTENER_DESTINATION, 'string', False)]

   singleton = False

   category = CATEGORY_GENERAL_SYSTEM_SETTING
   component = COMPONENT_MANAGED_AGENT_CONFIG

   # Need to define some common parent for random system config stuff, or
   # maybe just for CIM-related stuff? System Management Config?
   parentProfiles = [ cimIndicationsProfile.CimIndications ]

   @staticmethod
   def _GetHostnameIp(hostServices):
      """Helper function that retrieves the current system's hostname and IP
      """
      dnsConfig = hostServices.hostSystemService.configManager.networkSystem.dnsConfig
      hostName = dnsConfig.hostName
      if dnsConfig.domainName:
         hostName = '%s.%s' % (dnsConfig.hostName, dnsConfig.domainName)

      # Initialize it to some invalid value that can't be present in the
      # CIM properties where we will use the IP address for substitution.
      ipFromHostname = '*! NONE !*'
      try:
         addrInfo = socket.getaddrinfo(hostName, None)

         # getaddrinfo returns a list of 5-tuples:
         #    (family, type, proto, canonname, sockaddr)
         # addrInfo[0] -- The first 5-tuples
         # addrInfo[0][4] -- The sockaddr
         # addrInfo[0][4] -- The address in the sockaddr structure
         theTempIP = addrInfo[0][4][0]
         if addrInfo[0][0] == socket.AF_INET6:
            #
            # Make the representation of IPv6 address consistent
            #
            isValid, theTempIP = StandardizeIPv6Address(ipFromHostname)
            if isValid:
               ipFromHostname = theTempIP
         else:
            ipFromHostname = theTempIP
      except Exception as e:
         # Hopefully the code to get the IP address from the management nic will
         # work. If not, then we'll return the garbage IP value and the
         # extracted host profile just won't have the IP substitution.
         log.warn('Failed to resolve IP address from hostname %s: %s' % \
                  (hostName, str(e)))
      ip = ipFromHostname
      log.debug(
         'CIM Indication plugin found hostname %s and ip %s for hostname' % \
         (hostName, ipFromHostname))

      try:
         vnicMgrInfo = hostServices.hostConfigInfo.config.virtualNicManagerInfo
         for netConfig in vnicMgrInfo.netConfig:
            if netConfig.nicType == 'management':
               mgmtVnics = ResolveLinks(netConfig.selectedVnic, netConfig)
               if not mgmtVnics:
                  log.warn('CIM Indication plugin did not find any mgmt vnics')
                  break

               mgmtVnicIPs = [ vnic.spec.ip.ipAddress for vnic in mgmtVnics ]
               log.debug('CIM Indication plugin found mgmt vnic IPs: ' + \
                         str(mgmtVnicIPs))
               # Cross check the ipFromHostname against the list of IP's for
               # the management vnics. If there is no match, then pick the
               # first management vnic to use as the IP address.
               if ipFromHostname not in mgmtVnicIPs:
                  # Select the first valid mgmt vnic IP address and use that
                  # instead
                  log.info('IP (%s) for hostname (%s) does ' % \
                              (ipFromHostname, hostName) + \
                           'not match mgmt vnic ip list %s. ' % \
                              str(mgmtVnicIPs))
                  for mgmtIp in mgmtVnicIPs:
                     if mgmtIp and not IsIPInaddrAny(mgmtIp):
                        log.info('CIM Indication plugin selecting first ' + \
                                 'valid mgmt vnic IP address as host IP: %s' % \
                                 mgmtIp)
                        ip = mgmtIp
                        break
               break
      except Exception as e:
         log.warn('Exception getting IP address from management vnic: ' + \
                  str(e))
         ip = ipFromHostname
      except:
         log.warn('Unknown exception getting IP address from management vnic')
         ip = ipFromHostname

      return (hostName, ip)

   @classmethod
   def ExtractConfig(cls, hostServices):
      """Retrieve the cim indication config using indcfg tool.
      """
      log.debug('CIMXML: CimXmlIndicationsProfile::ExtractConfig Enter')
      try:
         hostName, hostIp = cls._GetHostnameIp(hostServices)
         indicationSubscriptions = list()
         cfg = load_config()
         if not JSN_SUB_PROP in cfg:
            raise _CreateExceptionFromObject(EXTRACTION_EXCEPTION_MSG_KEY,
                                             "invalid json config")
         for sub in cfg[JSN_SUB_PROP]:
            indParams = dict()

            # Extract the necessary parameters from the listener/handler
            indParams[LISTENER_CLASS] = sub[JSN_H_CLASSNAME_PROP]
            listenerName = sub[JSN_HANDLER_PROP]
            listenerName = listenerName.replace(hostName, HOSTNAME_SUBSTITUTION)
            listenerName = listenerName.replace(hostIp, IPVX_SUBSTITUTION)
            indParams[LISTENER_NAME] = listenerName
            destSystemName = sub[JSN_H_SYSTEMNAME_PROP]
            destSystemName = destSystemName.replace(hostName, HOSTNAME_SUBSTITUTION)
            destSystemName = destSystemName.replace(hostIp, IPVX_SUBSTITUTION)
            indParams[LISTENER_SYSTEM_NAME] = destSystemName
            indParams[LISTENER_SYSTEM_CCN] = sub[JSN_H_SYSTEMCLASS_PROP]
            destURL = sub[JSN_DESTINATION_PROP]

            try:
               url = urlparse(destURL)
               if url.hostname == hostName:
                  destURL = destURL.replace(hostName, HOSTNAME_SUBSTITUTION)
                  destURL = destURL.replace(hostIp, IPVX_SUBSTITUTION)
               elif url.hostname == hostIp:
                  destURL = destURL.replace(hostIp, IPVX_SUBSTITUTION)
                  destURL = destURL.replace(hostName, HOSTNAME_SUBSTITUTION)
               else:
                  pos = destURL.index(url.hostname) + len(url.hostname)
                  destURL = destURL[:pos] + \
                            destURL[pos:].replace(hostName,
                                                  HOSTNAME_SUBSTITUTION)
                  destURL = destURL[:pos] + \
                            destURL[pos:].replace(hostIp, IPVX_SUBSTITUTION)
            except:
               log.warn('Fail to parse destination URL: %s' % str(destURL))
               destURL = destURL.replace(hostName, HOSTNAME_SUBSTITUTION)
               destURL = destURL.replace(hostIp, IPVX_SUBSTITUTION)

            indParams[LISTENER_DESTINATION] = destURL

            # Extract the necessary parameters from the filter
            indParams[FILTER_CLASS] = sub[JSN_F_CLASSNAME_PROP]
            filterName = sub[JSN_FILTER_PROP]
            filterName = filterName.replace(hostName, HOSTNAME_SUBSTITUTION)
            filterName = filterName.replace(hostIp, IPVX_SUBSTITUTION)
            indParams[FILTER_NAME] = filterName
            filtSystemName = sub[JSN_F_SYSTEMNAME_PROP]
            filtSystemName= filtSystemName.replace(hostName, HOSTNAME_SUBSTITUTION)
            filtSystemName = filtSystemName.replace(hostIp, IPVX_SUBSTITUTION)

            indParams[FILTER_SYSTEM_NAME] = filtSystemName
            indParams[FILTER_SYSTEM_CCN] = sub[JSN_F_SYSTEMCLASS_PROP]
            indParams[QUERY] = sub[JSN_QUERY_PROP]
            indParams[QUERY_LANGUAGE] = sub[JSN_QUERY_LANGUAGE_PROP]
            indParams[SOURCE_NAMESPACE] = sub[JSN_SOURCE_NAMESPACE_PROP]
            indParams[SOURCE_NAMESPACES] = sub[JSN_SOURCE_NAMESPACES_PROP]
            if not indParams[SOURCE_NAMESPACES]:
               indParams[SOURCE_NAMESPACES] = [ indParams[SOURCE_NAMESPACE] ]

            indicationSubscriptions.append(indParams)
      except Exception as e:
         exc = _CreateExceptionFromObject(EXTRACTION_EXCEPTION_MSG_KEY, e)
         raise exc
      except:
         exc= CreateLocalizedException(
                 None, UNKNOWN_EXTRACTION_EXCEPTION_MSG_KEY)
         raise exc
      finally:
         log.debug('CIMXML: CimXmlIndicationsProfile::ExtractConfig Exit')
      return indicationSubscriptions


   @classmethod
   def SetConfig(cls, config, hostServices):
      """For the CimXmlIndicationsProfile, the config parameter should contain
         a list of dicts, where each dict contains the parameters needed to
         reconstitute a single indication subscription.
      """
      log.debug('CIMXML: xCimXmlIndicationsProfile::SetConfig Enter')

      # Get sfcbd status here
      # if it is running then stop it first
      isrunning = is_sfcbrunning()
      if isrunning:
         stop_sfcb()
      # clear all subscription first
      clear_config()

      hostName, hostIp = cls._GetHostnameIp(hostServices)

      try:
         data = { JSN_SUB_PROP : [] }
         for indParams in config:
            sub = dict()
            sub[JSN_F_CLASSNAME_PROP] = indParams[FILTER_CLASS]
            filtSystemName = indParams[FILTER_SYSTEM_NAME]
            filtSystemName = filtSystemName.replace(HOSTNAME_SUBSTITUTION, hostName)
            filtSystemName = filtSystemName.replace(IPVX_SUBSTITUTION, hostIp)
            sub[JSN_F_SYSTEMNAME_PROP] = filtSystemName
            filtName = indParams[FILTER_NAME]
            filtName = filtName.replace(HOSTNAME_SUBSTITUTION, hostName)
            filtName = filtName.replace(IPVX_SUBSTITUTION, hostIp)
            sub[JSN_FILTER_PROP] = filtName
            sub[JSN_F_SYSTEMCLASS_PROP] = indParams[FILTER_SYSTEM_CCN]
            sub[JSN_QUERY_PROP] = indParams[QUERY]
            sub[JSN_QUERY_LANGUAGE_PROP] = indParams[QUERY_LANGUAGE]
            # SourceNamespace and SourceNamespaces are optional (although one or
            # the other really should be set...).
            if indParams[SOURCE_NAMESPACE]:
               sub[JSN_SOURCE_NAMESPACE_PROP] = indParams[SOURCE_NAMESPACE]
            if indParams[SOURCE_NAMESPACES]:
               sub[JSN_SOURCE_NAMESPACES_PROP] = indParams[SOURCE_NAMESPACES]

            sub[JSN_H_CLASSNAME_PROP] = indParams[LISTENER_CLASS]
            destSystemName = indParams[LISTENER_SYSTEM_NAME]
            destSystemName = destSystemName.replace(HOSTNAME_SUBSTITUTION, hostName)
            destSystemName = destSystemName.replace(IPVX_SUBSTITUTION, hostIp)
            sub[JSN_H_SYSTEMNAME_PROP] = destSystemName
            destName = indParams[LISTENER_NAME]
            destName = destName.replace(HOSTNAME_SUBSTITUTION, hostName)
            destName = destName.replace(IPVX_SUBSTITUTION, hostIp)
            sub[JSN_HANDLER_PROP] = destName
            sub[JSN_H_SYSTEMCLASS_PROP] = indParams[LISTENER_SYSTEM_CCN]
            destURL = indParams[LISTENER_DESTINATION]
            destURL = destURL.replace(HOSTNAME_SUBSTITUTION, hostName)
            destURL = destURL.replace(IPVX_SUBSTITUTION, hostIp)
            sub[JSN_DESTINATION_PROP] = destURL
            data[JSN_SUB_PROP].append(sub)
            log.debug("CIMXML: importing sub: %s" % sub)
         with open(TMP_CONFIG_FILE, "w") as cfg:
            json.dump(data, cfg)

         set_config(TMP_CONFIG_FILE)
         if not os.path.exists(DEBUG_FLAG):
            os.unlink(TMP_CONFIG_FILE)

      except Exception as err:
         raise _CreateExceptionFromObject(SUB_CREATION_EXCEPTION_MSG_KEY,
                                          [ str(sub), err ])
      except:
         exc= CreateLocalizedException(
                 None, UNKNOWN_EXTRACTION_EXCEPTION_MSG_KEY)
         raise exc
      finally:
         # if sfcbd is running originally then start it
         if isrunning:
            start_sfcb()
         log.debug('CIMXML: CimXmlIndicationsProfile::SetConfig Exit')
      # End of SetConfig()

