#!/usr/bin/python
# **********************************************************
# Copyright 2011-2015 VMware, Inc.  All rights reserved. -- VMware Confidential
# **********************************************************

__author__ = "VMware, Inc."


from pluginApi import ParameterMetadata, log, CreateLocalizedException, \
                      CATEGORY_ADVANCED_CONFIG_SETTING
from pluginApi.extensions import SimpleConfigProfile, \
                                 IpAddressLoopBackValidValidator, \
                                 HostnameListValidator, HostnameValidator
import shutil
import os
import errno
import socket

#
# Define the localization message catalog keys used by this profile
#
BASE_MSG_KEY = 'com.vmware.profile.Profile.hostsFile'
READ_ETC_HOSTS_FAIL = '%s.%s' % (BASE_MSG_KEY, 'FailedToReadHostsFile')
WRITE_ETC_HOSTS_FAIL = '%s.%s' % (BASE_MSG_KEY, 'FailedToWriteHostsFile')
BAD_ENTRY_ETC_HOSTS = '%s.%s' % (BASE_MSG_KEY, 'BadEntryHostsFile')
ESXCLI_IP_FETCH_ERROR = '%s.%s' % (BASE_MSG_KEY, 'EsxcliIpFetchError')

#Constants
HOSTS_FILE = '/etc/hosts'
HOSTS_FILE_BACKUP = '%s.%s' % (HOSTS_FILE, 'hostprofile')
HOSTS_FILE_HEADER = '# hosts file generated by host profile.\n'
HOSTS_FILE_COMMENT_DELIMITER = '#'
HOSTS_FILE_IPADDRESS = 'ipAddress'
HOSTS_FILE_HOSTNAME = 'hostName'
HOSTS_FILE_ALIAS = 'alias'
HOSTS_FILE_DESC = 'desc'

HOSTS_FILE_COMPONENT = 'HostsFileConfig'

LOCALHOST = 'localhost'
LOOPBACK_IPS = ['127.0.0.1', '::1']

class EtcHostsFileException(Exception):
   """ Exception related to all file IO errors with the /etc/hosts file
   """
   pass

class EtcHostsHandler:
   """Class that provides read/write functionality from
      the /etc/hosts file
   """

   def ConvertIPToBinary(self, ipAddr):
      """ Convert an IP address from its family-specific string format to a
          packed, binary format
      """
      if ':' in ipAddr:
         af = socket.AF_INET6
      else:
         af = socket.AF_INET
      try:
         ipaddress = socket.inet_pton(af, ipAddr)
      except socket.error as err:
         log.error('Error translating IP %s in /etc/hosts file' % ipAddr)
         # Should we raise an exception? Someone could have a badly formatted
         # /etc/hosts file ??
         fault = CreateLocalizedException(None, BAD_ENTRY_ETC_HOSTS,
                  {'entry' : ipAddr})
         raise fault

      return ipaddress

   def DoesIPMatch(self, ip, ipList):
      """ Check if the given IP string is present in the list of IPs
      """
      ipAddress = self.ConvertIPToBinary(ip)
      for ipItem in ipList:
         localIpAddress = self.ConvertIPToBinary(ipItem)

         if ipAddress == localIpAddress:
            return True

      return False

   def _ParseEntry(self, entry, entryMap, localIPs, inclLocalInterface = False):
      """ Reads an entry and returns it as an entryMap. Includes/ignores local
          host related entries based on the inclLocalInterface flag

          An entry in hosts file is of format:
          <IP> <hostname> [alias(es) ...] [#<comment>]
      """
      entry = entry.strip()
      if not entry or entry.startswith(HOSTS_FILE_COMMENT_DELIMITER):
         # ignore blank lines and lines that are comments
         return False

      # pull out the description/comment, else leave it ''
      mapping, sep, desc = entry.partition(HOSTS_FILE_COMMENT_DELIMITER)

      tokens = mapping.split()
      if len(tokens) < 2:
         log.warning('Incorrect format for an entry in %s: %s' % (HOSTS_FILE, entry))
         return False

      entryMap[HOSTS_FILE_IPADDRESS] = tokens[0]
      entryMap[HOSTS_FILE_HOSTNAME] = tokens[1]

      # Skip localhost addresses, if the flag says so
      if not inclLocalInterface and \
         self.DoesIPMatch(entryMap[HOSTS_FILE_IPADDRESS], localIPs):
         # We ignore loopback ips only if the hostname contains localhost
         # as the user may want to capture other loopback entries.
         if LOCALHOST in entryMap[HOSTS_FILE_HOSTNAME] or \
           not self.DoesIPMatch(entryMap[HOSTS_FILE_IPADDRESS], LOOPBACK_IPS):
            log.debug('Ignoring %s address while reading %s entries' \
                        % (entryMap[HOSTS_FILE_IPADDRESS], HOSTS_FILE))
            return False

      # Some juggling here, since there can be more than one alias
      alias = tokens[2:]

      if alias:
         entryMap[HOSTS_FILE_ALIAS] = alias

      if desc:
         entryMap[HOSTS_FILE_DESC] = desc

      return True

   def GetLocalInterfaceIPs(self, hostServices):
      """ Using esxcli get all the IPs on the local interfaces of the host
      """
      esxcliIpv4GetCmd = 'network ip interface ipv4 get'
      esxcliIpv6GetCmd = 'network ip interface ipv6 address list'

      ipAddrs = []
      ipv6Addrs = []
      status, output = hostServices.ExecuteEsxcli(esxcliIpv4GetCmd)
      if not status:
         ipAddrs = [ip['IPv4 Address'] for ip in output]
      else:
         log.error('esxcli command to fetch IPv4 addresses returned error: %s' \
                   % output)
         raise CreateLocalizedException(None, ESXCLI_IP_FETCH_ERROR,
                  {'error' : output})

      status, output = hostServices.ExecuteEsxcli(esxcliIpv6GetCmd)
      if not status:
         ipv6Addrs = [ip['Address'] for ip in output]
      else:
         log.error('esxcli command to fetch IPv6 addresses returned error: %s' \
                   % output)
         raise CreateLocalizedException(None, ESXCLI_IP_FETCH_ERROR,
                  {'error' : output})

      ipAddrs.extend(ipv6Addrs)
      return ipAddrs


   def GetConfigData(self, hostServices, inclLocalInterface = False):
      """ Reads contents of the /etc/hosts file and processes its entries
      """
      groupConfigMaps = []
      try:
         fileHandle = open(HOSTS_FILE, 'r')
         contents = fileHandle.readlines()
      except IOError as e:
         log.error('Error while reading the %s file' % HOSTS_FILE)
         raise EtcHostsFileException(str(e))
      finally:
         fileHandle.close()

      localIPs = []
      if not inclLocalInterface:
         localIPs = self.GetLocalInterfaceIPs(hostServices)
         localIPs.extend(LOOPBACK_IPS)

      for entry in contents:
         entryMap = {}
         if self._ParseEntry(entry, entryMap, localIPs, inclLocalInterface):
            # include only the valid entries
            groupConfigMaps.append(entryMap)

      return groupConfigMaps


   def _BuildEntry(self, entry):
      """ Build the entry string to write to the /etc/hosts file
      """
      ip = entry[HOSTS_FILE_IPADDRESS]
      host = entry[HOSTS_FILE_HOSTNAME]
      alias = ''
      desc = ''

      if HOSTS_FILE_ALIAS in entry and entry[HOSTS_FILE_ALIAS] is not None:
         alias = ' '.join(entry[HOSTS_FILE_ALIAS])
      if HOSTS_FILE_DESC in entry and entry[HOSTS_FILE_DESC] is not None:
         desc = '#%s' % entry[HOSTS_FILE_DESC]

      # TODO: Should use some formatting here to make the output file aesthetic
      output = '%s\t%s %s %s\n' % (ip, host, alias, desc)
      return output

   def _ComputeApplyConfig(self, curHostConfig, profileConfig):
      """ Compute the list of entries that should be put in the /etc/hosts file
          by comparing what is on the host and what is in the profile document.
      """
      log.debug('Computing the entries to be updated in the %s file' % HOSTS_FILE)
      outputConfig = []

      for curMap in curHostConfig:
         # We always persist the loopback entries that have localhost as the
         # hostname and we don't replace them with anything in the profile.
         if LOCALHOST in curMap[HOSTS_FILE_HOSTNAME]:
            outputConfig.append(curMap)
            continue
         bFound = False
         for profMap in profileConfig:
            if profMap[HOSTS_FILE_IPADDRESS] == curMap[HOSTS_FILE_IPADDRESS]:
               # existing entry should be updated by what is there in the
               # profile document
               bFound = True
               outputConfig.append(profMap)
               profileConfig.remove(profMap)
               break

         if not bFound:
            # Preserve any extra entries currently on the host. Currently, we
            # don't want to clear up existing entries in the hosts file, that
            # are not in the profile document.
            outputConfig.append(curMap)

      if profileConfig:
         # Any entries in the profile document but not on the host, add them.
         outputConfig.extend(profileConfig)

      return outputConfig


   def SetConfigData(self, profileConfig, hostServices):
      """ Computes the entries that should be written out and outputs them to
          the /etc/hosts file on the host
      """
      # Read the current /etc/hosts file on the host. Since we need to preserve
      # any localhost entries, ensure we pick those up too.
      curHostConfig = self.GetConfigData(hostServices, inclLocalInterface = True)
      # Compute what entries are needed to be written out
      outputConfig = self._ComputeApplyConfig(curHostConfig, profileConfig)
      try:
         # Create a backup of the original file so that we can restore it
         # later.
         #
         # Right now, not deleting the backup file from the filesystem - would
         # it be useful for the user to revert to it in case host profile does
         # something they don't like?
         shutil.copy2(HOSTS_FILE, HOSTS_FILE_BACKUP)
      except IOError as e:
         log.error('Error backing up the current %s file' % HOSTS_FILE)
         raise EtcHostsFileException(str(e))

      try:
         fileHandle = open(HOSTS_FILE, 'w')
         fileHandle.write(HOSTS_FILE_HEADER)
         for entry in outputConfig:
            output = self._BuildEntry(entry)
            fileHandle.write(output)
      except IOError as e:
         os.rename(HOSTS_FILE_BACKUP, HOSTS_FILE)
         log.error('Error while writing the %s file' % HOSTS_FILE)
         raise EtcHostsFileException(str(e))
      finally:
         fileHandle.close()

      # Try to remove the backup file
      try:
         os.unlink(HOSTS_FILE_BACKUP)
      except OSError as err:
         if err.errno == errno.ENOENT:
            log.debug('/etc/hosts backup file does not exist')
         else:
            raise EtcHostsFileException(str(err))
      except Exception as ex:
         raise EtcHostsFileException(str(ex))



class EtcHostsProfile(SimpleConfigProfile):
   """A Host profile that manages the /etc/hosts file settings
   """

   #
   # Define the required attributes
   #
   parameters = [ ParameterMetadata(HOSTS_FILE_IPADDRESS, 'string', False,
                                    paramChecker=
                                       IpAddressLoopBackValidValidator),
                  ParameterMetadata(HOSTS_FILE_HOSTNAME, 'string', False,
                                    paramChecker=HostnameValidator),
                  ParameterMetadata(HOSTS_FILE_ALIAS, 'string[]', True,
                                    paramChecker=HostnameListValidator) ,
                  ParameterMetadata(HOSTS_FILE_DESC, 'string', True) ]

   singleton = False

   # Currently, we want to ignore entries on the host, that are not part of the
   # host profile document for compliance and apply operations. For the
   # compliance operation, ignoreExtraOnSystem should do the trick.
   ignoreExtraOnSystem = True
   category = CATEGORY_ADVANCED_CONFIG_SETTING
   component = HOSTS_FILE_COMPONENT

   @classmethod
   def CheckPolicyComplianceHelper(cls, config, hostServices):
      """Etc/hosts file compliance check helper
      """
      # If the hostname configured from the hostprofile,
      # after apply the hostprofile, the item will be added to etc/hosts,
      # but when do the compliance check get the configure from etc/hosts
      # will ignore the localIPs, but that in the hostprofile
      # Details in PR# 1158433
      log.debug("Config %s from hostprofile" % config)
      etcHostsHandler = EtcHostsHandler()
      localIPs = etcHostsHandler.GetLocalInterfaceIPs(hostServices)
      for profMap in config:
         for hsKey, hsVal in profMap.items():
            if hsKey == "ipAddress":
               for ipItem in localIPs:
                  if hsVal == ipItem:
                     config.remove(profMap)
      return config

   @classmethod
   def ExtractConfig(cls, hostServices):
      """Gets the contents of the /etc/hosts file on the ESX system
      """
      etcHostsHandler = EtcHostsHandler()
      try:
         log.debug('Extracting config from %s on the host' % HOSTS_FILE)
         configMap = etcHostsHandler.GetConfigData(hostServices)
      except EtcHostsFileException as e:
         log.error('Extract config for %s failed. %s' % (HOSTS_FILE, str(e)))
         fault = CreateLocalizedException(None, READ_ETC_HOSTS_FAIL)
         raise fault

      return configMap


   @classmethod
   def SetConfig(cls, config, hostServices):
      """Sets the contents of the /etc/hosts file on the host
      """
      etcHostsHandler = EtcHostsHandler()
      try:
         log.debug('Writing config to %s file on the host' % HOSTS_FILE)
         etcHostsHandler.SetConfigData(config, hostServices)
      except EtcHostsFileException as e:
         log.error('Writing config to %s failed. %s' % (HOSTS_FILE, str(e)))
         fault = CreateLocalizedException(None, WRITE_ETC_HOSTS_FAIL)
         raise fault

