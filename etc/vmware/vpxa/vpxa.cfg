<config>

  <vpxa>
     <memoryCheckerTimeInSecs>30</memoryCheckerTimeInSecs>
     <datastorePrincipal>root</datastorePrincipal>
     <!-- Threshold that needs to be crossed before capacity changes are
     sent over as part of the host sync
     <respool>
        <changeThresholdInMB>2</changeThresholdInMB>
     </respool>
     -->
     <!-- This timeout is for need based use if in a slow Vmotion,
     the destination VMId cannot reach to vpxa from hostd within default 60 sec.
     The timeout value is in seconds.
     <vmotion>
        <vmIdAcquireTimeout>60</vmIdAcquireTimeout>
     </vmotion>
     -->
     <licenseExpiryNotificationThreshold>15</licenseExpiryNotificationThreshold>
  </vpxa>

  <log>
     <directory>/var/run/log</directory>

     <!-- default size(in bytes) of each log file before rolling over to next -->
     <maxFileSize>1048576</maxFileSize>

     <!-- default number of log files to rotate amongst -->
     <maxFileNum>10</maxFileNum>

     <!-- default memory log level -->
     <memoryLevel>verbose</memoryLevel>

     <outputToConsole>false</outputToConsole>
<outputToFiles>false</outputToFiles>
     <!-- syslog configuration. Only used if outputToSyslog is true. -->
     <outputToSyslog>true</outputToSyslog>
     <syslog>
        <!-- syslog identifier to use when logging -->
        <ident>Vpxa</ident>
        <!-- syslog facility to use when logging -->
        <facility>local4</facility>
        <!-- The section header contents are placed in this file at startup.
             When vmsyslogd rotates the vpxa log file, it logs the content of this
             file to syslog. This is being done so that we don't lose context on log
             rotations.
             IMPORTANT: Value needs to match that in onrotate entry in
             vmsyslog.d/vpxa.conf
         -->
        <logHeaderFile>/var/run/vmware/vpxaLogHeader.txt</logHeaderFile>
     </syslog>
  </log>

  <nfc>
     <loglevel>error</loglevel>
  </nfc>

  <level id="SoapAdapter.HTTPService.HttpConnection">
     <logName>SoapAdapter.HTTPService.HttpConnection</logName>
     <logLevel>info</logLevel>
  </level>

  <level id="SoapAdapter.HTTPService">
     <logName>SoapAdapter.HTTPService</logName>
     <logLevel>info</logLevel>
  </level>

  <httpNfc>
     <enabled>true</enabled>
     <accessMode>proxyAuto</accessMode>
  </httpNfc>

  <workingDir>/var/log/vmware</workingDir>

  <!-- We're restricted to 128 threads in a userworld, so limit vmacore
       threads to 14 and root LROs to 98.  vpxa uses 4 other vpx threads
       for various things, which leaves us a 2 thread buffer in case
       we missed accounting for something. -->
  <vmacore>
    <ssl>
      <doVersionCheck>false</doVersionCheck>
    </ssl>
    <!-- limit number of vmacore threads to 4 -->
    <threadPool>
      <TaskMax>4</TaskMax>
      <IoMax>9</IoMax>
      <ThreadStackSizeKb>128</ThreadStackSizeKb>
      <threadNamePrefix>vpxa</threadNamePrefix>
    </threadPool>
    <http>
      <defaultClientPoolConnectionsPerServer>
        300
      </defaultClientPoolConnectionsPerServer>
    </http>
  </vmacore>

  <task>
    <!-- limit number of vpx root LROs to 98 -->
    <maxThreads>98</maxThreads>
    <minCompletedLifetime>120</minCompletedLifetime>
    <completedMaxEntries>1000</completedMaxEntries>
  </task>

  <trace>
    <vmomi>
      <calls>false</calls>
    </vmomi>
    <mutex>
      <profiledMutexes>InvtLock</profiledMutexes>
    </mutex>
  </trace>
</config>

